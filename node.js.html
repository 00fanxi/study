<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="study.css">
  </head>
  <body>
    <h1>Node.js</h1>
    <div id=grid>
      <ol id=list>
        <li><a href="html.html">html</a></li>
        <li><a href="css.html">css</a></li>
        <li><a href="javascript.html">javascript</a></li>
				<li><a href="deeperjs.html">deeperjs</a></li>
				<li><a href="node.js.html">node.js</a></li>
        <li><a href="site.html">site</a></li>
				<li><a href="web.html">web</a></li>
				<li><a href="wish_list.html">wish list</a></li>
      </ol>
    <div id=contents>
			<h2>
				기타
			</h2>
			<ol>
				<li><span class="js">\</span> :  코드 안에서만 줄을 바꿀시<br>
				<span class="js">\n</span> :  코드 밖에서만 줄을 바꿀시<br>
				</li>
			</ol>
			
			<h2>
				literal
			</h2>
			
			<ol>
				<li><span class="js">template literal</span> : 물결무늬 밑에있는 따옴표(grave accent)</li>
				<li>변수는 <span class="js">${variable}</span> : 변수로 인식</li>
				<li>숫자의 덧셈도<span class="js">${1+1}</span> : 2로 나옴</li>
			</ol>
			
			<h2>
				url
			</h2>
			
			<ol>
				<li><b>http :// opentutorials.org : 3000 / main ? id=HTML&page=12</b></li>
				<li><b>http</b> = protocol</li>
				<li><b>opentutorials.org</b> = host(domain) : 특정한 인터넷에 연결된 컴퓨터를 가리키는 주소</li>
				<li><b>3000</b> = port(포트번호/ 디폴트:80), 한 대의 컴퓨터 안에 여러대의 서버가 있을 수 있다. <br>
				클라이언트가 접속했을 때 그 중의 어떤 서버와 통신할지 결정. (300번 포트와 연결된 서버와 통신)</li>
					<li><b>main</b> = path(어떤 Directory의 어떤 file인지)</li>
					<li><b>id=HTML&page=12</b> = query string</li>
				<li><b>query string</b> : 시작은 물음표로(?), 값과 값 사이는 &(ampersend) 사용, 값의 이름과 값은 =(equal)로 구분</li>
				<li>url,fs와 http는 모듈.<br>
				모듈이란? node.js가 가지고 있는 수많은 기능들을 비슷한 것들끼리 그룹핑 해놓은걸 모듈이라고 한다<br>
					<span class="js">var url = require('url');</span> : require은 모듈을 불러옴. <br>
					앞으로 url이라는 변수로 url이라는 모듈을 불러올거야 라는 뜻.</li>
				<li><span class="js">var url = require('url');<br>
					var _url = request.url;<br>
					var queryData = url.parse(_url,true).query;<br>
					console.log(queryData.id);<br>
					response.end(queryData.id);<br></span>
				query string 부분의 값이 표시된다.</li>
				
				<li>parse:분석<br>
				Parsing Query String in node js</li>
			</ol>
			
			<ol>
				<li></li>
			</ol>
			
			<h2>
				CRUD(Create Read Update Delete)
			</h2>
			
			<ol>
				<li>정보를 다루는 핵심적인 요소.</li>
				<li>생성과 읽기(Create and Read)를 먼저 익히고 Update와 Delete를 배우자.</li>
				<li><span class="js">fs.read(path[,options],callback)</span> : 파일 읽기</li>
				<li><span class="js">const fs = require('fs');<br>
					fs.readFile('sample.txt', 'utf8', function(err,data){<br>
					&nbsp console.log(data);<br>
					});</span>
				</li>
				<li>cd.. : 부모 디렉토리</li>
				<li>dir/w : 디렉토리 내부 파일 보기</li>
			</ol>
			
			<h2>
				본문도 바꾸기
			</h2>
			
			<ol>
				<li>data폴더를 만들어 각 페이지의 본문 내용만 복사해서 파일명을 query string의 이름과 동일하게<br>
				만들어서 저장. <span class="js">fs.readFile(`data/${queryData.id}`,'utf8',function(err,description)
				</span> 으로 query string과 파일명이 일치하는 파일을 읽게하고 template 안에 파일 즉, 본문이 들어갈 부분에<br>
				${description}을 입력한다.</li>
			</ol>
			
			<h2>
				콘솔에서의 입력값
			</h2>
			
			<ol>
				<li>IO(input and output)</li>
				<li>input의 종류 : Parameter = 입력되는 정보의 형식/ argument = Parameter에 맞게 입력된 값.
				</li>
				<li>web에서는 url parmeter를 통해 입력 값(argument)을 주고 그 결과를 HTMl로 출력(output).</li>
				<li>output : cosole에서는 그 값을 console 화면에 출력, 프린트로 출력, 파일로 저장</li>
					<li><span class="js">var args = process.argv;<br>
					console.log(args);</span><br>
					배열을 출력. 첫번째 자리에는 node js runtime이 어디에 위치하고 있는지 알려줌.<br>
					두번째 자리에는 실행시킨 이 파일에 대한 경로 제공.<br>
					세번째 자리부터 콘솔에서 실행시킨 파일명 뒤에 작성한 입력값을 출력.<br>
				따라서, <span class="js">var args = process.argv;<br>
					console.log(args[2]);</span><br>
					이라고 파일을 수정하고 콘솔에 <span class="js">node paramters.js zheng</span>
					이라고 치면 'zheng'이라는 배열의 값만 출력.</li>
				<li><span class="js">if(args[2]==='1'){<br>
					&nbsp console.log('a');<br>
					}else{<br>
					&nbsp console.log('b');<br>
					}</span><br>
					배열의 인덱스 2의 값을 비교하여 결과를 출력하는 조건문.<br>
					콘솔에 입력한 숫자는 문자로 인식.</li>
			</ol>
			
			<h2>
				Not found 구현
			</h2>
			<ol>
				<li><span class="js">console.log(url.parse(_url,true));</span><br>
				Url {<br>
				&nbsp	protocol: null,<br>
				&nbsp	slashes: null,<br>
				&nbsp	auth: null,<br>
				&nbsp	host: null,<br>
				&nbsp	port: null,<br>
				&nbsp	hostname: null,<br>
				&nbsp	hash: null,<br>
				&nbsp	search: '?id=HTML',<br>
				&nbsp	query: [Object: null prototype] { id: 'HTML' },<br>
				&nbsp	pathname: '/',<br>
				&nbsp	path: '/?id=HTML',<br>
				&nbsp	href: '/?id=HTML'<br>
				}<br>
				이런 배열을 출력.
				</li>
				<li>
					pathname : 경로. 말그대로 파일을 서버에서 불러올때 그 파일이 위치한 곳을 나타냄/로 이루어짐.<br>
					path : query string을 포함해서 pathname 뒤에 오는 모든 것.<br>
					<span class="js">
						if(pathname === '/'){<br>
							response.writeHead(200);<br>
							response.end(template);<br>
						}else{<br>
							response.writeHead(404);<br>
							response.end('Not found');<br>
						}<br>
					</span>
					절대경로로 파일을 찾을 경우  Not Found로 보내버림.<br>
					response.writeHead(200) = Server가 browser한테 파일을 성공적으로 전송했다.
					response.writeHead(404) = 파일을 찾을 수 없음.
				</li>
			</ol>
			<h2>
				synchrodous(동기) 와 asynchronous(비동기)
			</h2>
			
			<ol>
				<li>동기 : 일을 하나 끝내면 다음일로 한번에 하나씩 순차적으로 하는 것.</li>
				<li>비동기 : 일을 하나 시켜 놓고 끝나면 알리게 한다음 그동안 다른일들을 처리하는 것.<br>
				효율적이지만 매우 복잡.</li>
			
			</ol>
		</div>
		</div>
	</body>
</html>


























